<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Viewer</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { padding: 0; }
        .data-table { width: 100%; border-collapse: collapse; margin-bottom: 10px; font-size: 0.95rem; }
        .data-table th, .data-table td { border: 1px solid var(--gold); padding: 8px; text-align: left; vertical-align: top; }
        .data-table th { background: var(--parchment-dark); color: var(--red-dark); font-family: "Cinzel", serif; white-space: nowrap; }
        .kv-table th:first-child { width: 30%; white-space: normal; }
        .data-table td { background: rgba(255,255,255,0.5); font-family: "Crimson Text", serif; }
        .file-section { margin-bottom: 24px; border: 2px solid var(--gold); padding: 16px; border-radius: 8px; background: rgba(255,255,255,0.3); box-shadow: 0 2px 8px var(--shadow); }
        .file-title { font-family: "Cinzel", serif; color: var(--red); font-size: 1.2rem; margin-bottom: 12px; border-bottom: 1px dashed var(--gold); padding-bottom: 6px; font-weight: bold; }
        .json-key { font-weight: bold; color: var(--ink); }
        .json-val pre { margin: 0; white-space: pre-wrap; font-family: monospace; font-size: 0.85rem; color: var(--ink-light); }
        .data-viewer-container {
            width: 100%; min-height: 100vh; background: var(--parchment); padding: 24px; position: relative; box-sizing: border-box;
        }
        .data-viewer-container::before {
            content: ""; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(42, 24, 16, 0.02) 2px, rgba(42, 24, 16, 0.02) 4px);
            pointer-events: none; opacity: 0.5;
        }
        .data-viewer-container > * { position: relative; z-index: 1; }
    </style>
</head>
<body>
    <div class="data-viewer-container">
        <div class="header">
            <h1>Data Viewer</h1>
            <div class="subtitle">Zip File Inspector</div>
        </div>

        <div class="field" style="text-align: center; padding: 20px; margin-bottom: 20px;">
            <label class="field-label" style="font-size: 1rem; margin-bottom: 10px; display: block;">Select a File</label>
            <input type="file" id="fileInput" accept=".zip" style="display: inline-block;">
            <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
                <button id="clearDataBtn" class="btn btn-danger" style="display: none; padding: 8px 16px; font-size: 0.9rem;" onclick="clearStorage()">Clear Saved Data</button>
                <button id="deleteDbBtn" class="btn btn-danger" style="padding: 8px 16px; font-size: 0.9rem;" onclick="deleteDatabase()">Delete DB</button>
            </div>
        </div>

        <div id="pagination" style="display:none; justify-content: center; gap: 15px; margin-bottom: 20px; align-items: center;">
            <button id="prevBtn" class="btn btn-secondary" onclick="changePage(-1)">Previous</button>
            <span id="pageInfo" style="font-family: 'Cinzel', serif; font-weight: bold; color: var(--red-dark);"></span>
            <button id="nextBtn" class="btn btn-secondary" onclick="changePage(1)">Next</button>
        </div>

        <div id="output"></div>
    </div>

    <script>
        let allFiles = [];
        let currentPage = 1;
        const itemsPerPage = 1;
        
        // IndexedDB Configuration
        const DB_NAME = 'DndZipDB';
        const STORE_NAME = 'files';
        const DB_VERSION = 1;

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }

        function formatValue(val) {
            if (val === null || val === undefined) return '<span style="color:var(--ink-light); font-style:italic">null</span>';
            if (typeof val !== 'object') return String(val);
            
            if (Array.isArray(val)) {
                if (val.length === 0) return '<span style="color:var(--ink-light); font-style:italic">Empty List</span>';
                
                // Check if array of objects (and not nulls)
                const isObjArray = val.length > 0 && typeof val[0] === 'object' && val[0] !== null;
                
                if (isObjArray) {
                    // Collect all unique keys
                    const keys = new Set();
                    val.forEach(item => {
                        if (item && typeof item === 'object') {
                            Object.keys(item).forEach(k => keys.add(k));
                        }
                    });
                    const headers = Array.from(keys);
                    
                    if (headers.length === 0) return '[]';

                    let html = '<div style="overflow-x:auto;"><table class="data-table"><thead><tr>';
                    headers.forEach(h => html += `<th>${h}</th>`);
                    html += '</tr></thead><tbody>';
                    
                    val.forEach(item => {
                        html += '<tr>';
                        headers.forEach(h => {
                            const v = item ? item[h] : undefined;
                            html += `<td>${formatValue(v)}</td>`;
                        });
                        html += '</tr>';
                    });
                    html += '</tbody></table></div>';
                    return html;
                } else {
                    // Array of primitives
                    return `<div style="display:flex; flex-wrap:wrap; gap:4px;">${val.map(v => `<div class="tag-item" style="background:white; border:1px solid var(--gold); padding:2px 6px; border-radius:4px;">${formatValue(v)}</div>`).join('')}</div>`;
                }
            }
            
            // Object
            let html = '<table class="data-table kv-table"><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>';
            for (const key in val) {
                html += `<tr><td class="json-key">${key}</td><td class="json-val">${formatValue(val[key])}</td></tr>`;
            }
            html += '</tbody></table>';
            return html;
        }

        function renderPage() {
            const output = document.getElementById('output');
            output.innerHTML = '';
            
            if (allFiles.length === 0) {
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            document.getElementById('pagination').style.display = 'flex';
            document.getElementById('pageInfo').textContent = `File ${currentPage} of ${allFiles.length}`;
            document.getElementById('prevBtn').disabled = currentPage === 1;
            document.getElementById('nextBtn').disabled = currentPage === allFiles.length;

            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, allFiles.length);
            const filesToShow = allFiles.slice(startIndex, endIndex);

            filesToShow.forEach(file => {
                let displayContent = '';
                try {
                    const json = JSON.parse(file.content);
                    displayContent = formatValue(json);
                } catch (e) {
                    displayContent = `<pre style="background:white; padding:10px; border:1px solid var(--gold); border-radius:4px; overflow-x:auto;">${file.content}</pre>`;
                }

                const div = document.createElement('div');
                div.className = 'file-section';
                div.innerHTML = `<div class="file-title">${file.name}</div>${displayContent}`;
                output.appendChild(div);
            });
        }

        window.changePage = function(delta) {
            const newPage = currentPage + delta;
            if (newPage >= 1 && newPage <= allFiles.length) {
                currentPage = newPage;
                renderPage();
                window.scrollTo(0, 0);
            }
        };

        async function saveToStorage() {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                await new Promise((resolve, reject) => {
                    const req = store.put(allFiles, 'currentData');
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                });
                updateClearButton();
            } catch (e) {
                console.error("IDB Save failed", e);
                alert("Failed to save to IndexedDB: " + e.message);
            }
        }

        async function loadFromStorage() {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const data = await new Promise((resolve, reject) => {
                    const req = store.get('currentData');
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
                
                if (data) {
                    allFiles = data;
                    currentPage = 1;
                    renderPage();
                    updateClearButton();
                }
            } catch (e) {
                console.error("IDB Load failed", e);
            }
        }

        window.clearStorage = async function() {
            if (confirm("Remove saved data from browser?")) {
                try {
                    const db = await openDB();
                    const tx = db.transaction(STORE_NAME, 'readwrite');
                    const store = tx.objectStore(STORE_NAME);
                    await new Promise((resolve, reject) => {
                        const req = store.delete('currentData');
                        req.onsuccess = () => resolve();
                        req.onerror = () => reject(req.error);
                    });
                    allFiles = [];
                    renderPage();
                    updateClearButton();
                    document.getElementById('fileInput').value = '';
                } catch (e) {
                    console.error("IDB Clear failed", e);
                }
            }
        };

        window.deleteDatabase = function() {
            if (confirm("Completely delete the IndexedDB database? This will refresh the page.")) {
                const req = indexedDB.deleteDatabase(DB_NAME);
                req.onsuccess = () => {
                    alert("Database deleted successfully.");
                    location.reload();
                };
                req.onerror = (e) => {
                    console.error("Error deleting DB:", e);
                    alert("Error deleting database.");
                };
                req.onblocked = () => {
                    alert("Database deletion blocked. Please close other tabs using this app and try again.");
                };
            }
        };

        function updateClearButton() {
            const btn = document.getElementById('clearDataBtn');
            if (allFiles.length > 0) {
                btn.style.display = 'inline-block';
            } else {
                btn.style.display = 'none';
            }
        }

        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const output = document.getElementById('output');
            output.innerHTML = '<div style="text-align:center; font-style:italic;">Processing zip file...</div>';
            document.getElementById('pagination').style.display = 'none';
            
            allFiles = [];
            currentPage = 1;

            try {
                const zip = await JSZip.loadAsync(file);
                const promises = [];

                zip.forEach(async (relativePath, zipEntry) => {
                    if (!zipEntry.dir) {
                        promises.push(zipEntry.async("string").then(content => ({
                            name: relativePath,
                            content: content
                        })));
                    }
                });

                allFiles = await Promise.all(promises);
                // Sort files by name
                allFiles.sort((a, b) => a.name.localeCompare(b.name));
                
                output.innerHTML = '';
                renderPage();
                saveToStorage();

            } catch (error) {
                output.innerHTML = `<div style="color: red">Error reading zip: ${error.message}</div>`;
            }
        });

        // Initialize
        loadFromStorage();
    </script>
</body>
</html>